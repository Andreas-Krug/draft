<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html;charset=UTF-8" http-equiv="Content-Type"/>
    <meta charset="UTF-8"/>
    <title>Range arguments for container constructors and methods, wording revision 2</title>
<style type="text/css">
body {color: #000000; background-color: #FFFFFF;}

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre > code:only-child {display: inline-block; white-space: inherit}
code {white-space: nowrap}
code wbr {white-space: normal}

/*
.wording { max-width: 90ex; }
.wording .sectnum { margin-right: 1em; }
.wording .sectname { display: block; float: right;  }

section.numbered { counter-reset: par-num; }
.wording p:before, .wording dt:before {
    content: counter(par-num) " "; counter-increment: par-num;
    font-size: 80%; position: absolute; left: 2em}
*/
.wording td { border-top: thin solid black; border-bottom: thin solid black; }

section.function { clear: both; }
.attributes, .attribute {margin-left: 2em}

.docinfo {float: right}
.docinfo p {margin: 0; text-align:right; font-style: italic}

section {padding-left: 1em}
section header {margin-left: -1em}

h2, h3, h4, h5, h6 { margin-bottom: .75em }
h5, h6 { font-size: 1em; }
.wording h4 { font-size: 1.17em }
p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}
.todo dt:not(:first-child) {margin-top: .5em}
p, li, dd, table {max-width: 80ex}

table { border: double; margin: 1em; border-collapse: collapse; }
td { text-align: left; }

.example {display: inline-block; clear: both; margin-left: 1ex;
          border: thin solid #0e0; background-color: #f8f8f8; padding: 1ex}

div.note > *:first-child::before {content: "Note: "; display: inline; font-weight: bold}
div.note {display: inline-block; margin-left: 1ex; border: thin solid #8f8;
          padding: 1ex; background-color: #efe}

:target {background-color: #fed}
</style>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript">//<![CDATA[
$(function() {
    var next_id = 0
    function find_id(node) {
        // Look down the first children of 'node' until we find one
        // with an id. If we don't find one, give 'node' an id and
        // return that.
        var cur = node[0];
        while (cur) {
            if (cur.id) return cur.id;
            if (cur.tagName == 'A' && cur.name)
                return cur.name;
            cur = cur.firstChild;
        };
        // No id.
        node.attr('id', 'gensection-' + next_id++);
        return node.attr('id');
    };

    // Put a table of contents in the #toc nav.

    // This is a list of <ol> elements, where toc[N] is the list for
    // the current sequence of <h(N+2)> tags. When a header of an
    // existing level is encountered, all higher levels are popped,
    // and an <li> is appended to the level
    var toc = [$("<ol/>")];
    $(':header').not('h1').each(function() {
        var header = $(this);
        // For each <hN> tag, add a link to the toc at the appropriate
        // level.  When toc is one element too short, start a new list
        var levels = {H2: 0, H3: 1, H4: 2, H5: 3, H6: 4};
        var level = levels[this.tagName];
        if (typeof level == 'undefined') {
            throw 'Unexpected tag: ' + this.tagName;
        }
        // Truncate to the new level.
        toc.splice(level + 1, toc.length);
        if (toc.length < level) {
            // Omit TOC entries for skipped header levels.
            return;
        }
        if (toc.length == level) {
            // Add a <ol> to the previous level's last <li> and push
            // it into the array.
            var ol = $('<ol/>')
            toc[toc.length - 1].children().last().append(ol);
            toc.push(ol);
        }
        var header_text = header.text();
        toc[toc.length - 1].append(
            $('<li/>').append($('<a href="#' + find_id(header) + '"/>')
                              .text(header_text)));
    });
    $('#toc').append(toc[0]);
})
//]]></script>
</head>
<body>
  <header>
    <div class="docinfo">
      <p>ISO/IEC JTC1 SC22 WG21 N????<!--3513--></p>
      <p>Date: <time pubdate="">2013-01-11</time></p>
      <address>
        <p>Jeffrey Yasskin &lt;<a href="mailto:jyasskin@google.com">jyasskin@google.com</a>&gt;</p>
      </address>
    </div>
    <h1>Range arguments for container constructors and methods, wording revision 2</h1>
  </header>

  <p><small><a href="#maincontent">Skip table of contents</a></small></p>
  <nav id="toc"></nav>

  <a id="maincontent"></a>
  <section>
    <header><h2 id="overview">Overview</h2></header>
    <p>The STL brought the notion of a <dfn>range</dfn> to C++, expressed as a
    pair of iterators.  C++11 added the range-based for loop, which iterates
    over a single object for which <code>begin(x)</code> and <code>end(x)</code>
    return that pair of iterators.  The <a
    href="http://www.boost.org/libs/range">Boost.Range</a> library extends this
    to a full library of algorithms based on ranges as single objects. We'd like
    to be able to experiment with such a library in a series of Technical
    Specifications between now and C++17, but the LWG preference is that TSes
    shouldn't change the definitions of any existing types, so we need to add a
    minimal amount of range-object support to the C++14 standard library so that
    range TSes can interoperate.  This paper attempts to add that support.</p>

    <p>I drew inspiration from two places in adding this support.  First, the
    range-based for loop ([stmt.ranged]) defines the minimal interface for a
    range object:</p>
    <ul>
      <li><code>begin(range)</code> and <code>end(range)</code>, with
      <code>std::begin</code> and <code>std::end</code> in the candidate set,
      return types that can initialize variables in the same
      <code>auto</code>-typed declaration. (Note that [stmt.ranged] specifies
      individual cases for arrays, objects with <code>.begin()</code> and
      <code>.end()</code> members, and objects for which <code>begin()</code>
      and <code>end()</code> can be found via ADL, but <code>std::begin()</code>
      and <code>std::end()</code> include code for arrays and objects with
      <code>.begin()</code> and <code>.end()</code> members, so this
      library-oriented proposal simply relies on them.)</li>

      <li>The type returned by <code>begin(range)</code> and
      <code>end(range)</code> supports <code>operator*</code>,
      <code>operator++</code>, and <code>operator!=</code> in the pattern
      defined by Input Iterators.  This proposal slightly strengthens that into
      a requirement that <code>begin(range)</code> and <code>end(range)</code>
      actually return an Input Iterator type, although the
      <code>enable_if</code> logic for implementations is only required to check
      for the presence of <code>operator*</code>.</li>
    </ul>

    <p>Second, many container methods have an overload taking an
    <code>initializer_list&lt;value_type></code> argument.  This proposal takes
    that as a good indication of the methods that can usefully take a range
    argument and adds such an overload parallel to each one of those.  This is
    the same as the set of methods taking a templated Iterator pair except for
    one <code>priority_queue</code> constructor.</p>
  </section>

  <section>
    <header><h2 id="range-arg">The <code>Range</code> template argument</h2></header>

    <p>There are many sorts of range types, so container methods taking ranges
    either have to be templated, or we'd need to define a single range type with
    a templated converting constructor.  I proposed such a type in <a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html">N3350</a>,
    but the exact set of methods that the type needs is somewhat contentious, so
    this paper proposes templating the methods instead.</p>

    <p>A templated method could either take a <code>const Range&amp;</code> or a
    <code>Range&amp;&amp;</code> (where <code>Range</code> is a template
    argument).  Both of these can capture arguments that should implicitly
    convert to the argument types of another overload of the same method, so we
    need some <code>enable_if</code> logic for both.  <code>const
    Range&amp;</code> would naturally leave <code>Container&amp;</code>
    arguments for the <code>const Container&amp;</code> overload, but it would
    incorrectly capture <code>DerivedFromContainer</code> arguments, just like
    <code>Range&amp;&amp;</code> would.  <code>Range&amp;&amp;</code> lets us
    allow library authors to move elements from rvalue arguments.  Because the
    necessary <code>enable_if</code> logic seems similar in both cases, I chose
    to take <code>Range&amp;&amp;</code>.</p>

    <p><a href="#range.requirements.implementations">The <code>enable_if</code> logic is
    specified</a> as:</p>

    <blockquote>
      <p>Several functions in the standard library take a template argument
      named "<code>Range</code>". These functions shall not participate in
      overload resolution if <code>Range</code> is not deduced to a range
      type. Further, if the function is a container or string’s constructor or
      operator=, and <code>decay&lt;Range>::type</code> is the type of the
      container or a type derived from the container type, the function shall
      not participate in overload resolution.</p>

      <p>Additionally, implementations may exclude these functions from overload
      resolution if Range's iterator type is not an Input Iterator type
      ([input.iterators]) or its value type is not convertible to the
      container’s value type, but the extent to which they do so is
      unspecified.</p>
    </blockquote>

    <p>Even with this text, <em>range types that define an implicit conversion
    to the container type with a non-default allocator, comparator, or hash
    instance</em> are going to have strange behavior when a conversion is
    requested.  With current language rules, it appears that copy-initialization
    will call the conversion operator, but direct-initialization will call the
    templated range constructor, losing any custom allocator, comparator, or
    hash instance the conversion operator attempts to set.  It's possible to
    work around this by explicitly passing them to the range constructor, but
    it's unlikely users will know to do so.  I believe such types are rare
    enough that this surprise is acceptable.</p>

    <p>The proposed text also says that <a href="#unspecified-state">ranges
    passed as rvalues are "left in an unspecified state after the call."</a>
    When a range is just a reference to
    objects owned elsewhere, this text doesn't allow moving those objects, since
    that leaves more than just the <em>range</em> in an unspecified state.
    However, if the implementation can detect that the range owns the objects it
    iterates over, this wording allows those objects to be moved.  I leave the
    technique for detecting this as a QoI issue.</p>
  </section>

  <section>
    <header><h2 id="examples">Examples</h2></header>

    <h3 id="boost.range.example">Using Boost.Range with standard containers</h3>
    <p>Boost has a fairly extensive collection of range-based algorithms, but
    they can't quite interoperate perfectly with standard containers because the
    containers are missing appropriate constructors.  This paper allows the
    following code (adapted from the <a
    href="http://www.boost.org/doc/libs/1_51_0/libs/range/doc/html/range/reference/adaptors/reference/replaced.html">Boost.Range
    docs</a>) to work:</p>

<pre class="example"><code>#include &lt;boost/range/adaptor/replaced.hpp>
#include &lt;boost/range/adaptor/reversed.hpp>
#include &lt;boost/range/algorithm/copy.hpp>
#include &lt;deque>
#include &lt;iostream>
#include &lt;vector>

int main() {
    using namespace boost::adaptors;

    std::deque&lt;int> input{1,2,3,2,5,2,7,2,9};

    std::vector&lt;int> output{
      input | replaced(2, 10) | reversed};

    boost::copy(output, std::ostream_iterator&lt;int>(std::cout, ","));
}
</code></pre>

    <p>This prints "<samp>9,10,7,10,5,10,3,10,1,</samp>".</p>

    <p>You'll note that this paper doesn't propose any new algorithm overloads
    taking ranges, so the above example still needs to call
    <code>boost::copy</code> instead of <code>std::copy</code>. That's because a
    TS can add new functions in its own namespace, so we can go through several
    revisions getting them exactly right, rather than needing to debate a whole
    algorithms library for C++14.</p>

    <h3 id="split.example"><a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3430.html">N3430's
    split()</a> without a conversion operator</h3>

    <p>The primary discomfort the LWG had with the <code>split()</code> proposal
    was that its implicit conversion operator to any container type was just a
    hack around the lack of range support (<a
    href="http://wiki.edg.com/twiki/bin/view/Wg21portland2012/LibraryWorkingGroup#Afternoon_AN2">Portland
    discussion</a>).  This paper delivers enough range support to remove
    <code>split()</code>'s conversion operator.</p>

<pre class="example"><code>vector&lt;string> v{std::split("a,b,c", ",")};
deque&lt;string> d{std::split("a,b,c", ",")};
set&lt;string> s{std::split("a,b,c", ",")};
list&lt;string> l{std::split("a,b,c", ",")};
vector&lt;string_ref> v2{std::split("a,b,c", ",")};  // No data copied.
assert(v.size() == 3);  // "a", "b", "c" </code></pre>

<p>Conversion to either <code>string</code> or <code>string_ref</code> is
accomplished by having <code>split()</code>'s result's iterator return proxy
objects that are implicitly convertible to either type.  The <a
href="#enable.if.spec"><code>enable_if</code> logic</a> specifically allows
implicit conversions to the container's <code>value_type</code> so that this
works.</p>

  </section>

  <section>
    <h2 id="revision-history">Paper revision history</h2>

    <p>This paper updates <a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3456.html">N3456</a>
    by moving the range requirements out of [containers] and into the library's
    introduction ([utility.requirements]).</p>

    <p>The <a
    href="https://github.com/google/cxx-std-draft/blob/range-args-paper/range_args.html">most
    recent version of this paper</a> is maintained on GitHub.</p>
  </section>

  <hr/>

  <section class="wording">
    <header><h2 id="wording">Wording</h2></header>

    <p>Wording changes are being maintained at <a
    href="https://github.com/google/cxx-std-draft/compare/range-args">https://github.com/google/cxx-std-draft/compare/range-args</a>
    and a snapshot of the changes, relative to <a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf">N3485</a>,
    is copied below.  An early implementation is at <a
    href="https://github.com/google/libcxx/compare/range-args">https://github.com/google/libcxx/compare/range-args</a>.
    Patches and pull requests are welcome against both.</p>

    <p>As an editorial matter, several of these new functions could be specified
    more concisely using [structure.specifications]'s "equivalent to" wording.
    They're specified more verbosely in order to match the existing functions
    around them.</p>

<h3 id="library">Clause 17, Library introduction</h3>

<h4>Modify [utility.requirements]</h4>
<p>[utility.arg.requirements] describes requirements on types and expressions
used to instantiate templates defined in the C++ standard
library. [swappable.requirements] describes the requirements on swappable types
and swappable expressions. [nullablepointer.requirements] describes the
requirements on pointer-like types that support null values. [hash.requirements]
describes the requirements on hash function objects. [allocator.requirements]
describes the requirements on storage allocators.<ins> [range.requirements]
describes the requirements on range types.</ins></p>

<h4 id="range.requirements">Add a sub-section under [utility.requirements],  "# Range requirements [range.requirements]"</h4>

<p>Objects of <code>Range</code> type (<code>Range</code> objects) refer to a
sequence of other objects using a pair of iterators accessed by
<code>begin()</code> and <code>end()</code> functions. <code>Range</code>
objects may or may not contain and own these other objects.</p>

<p>This subclause provides definitions for <code>Range</code> types and
expressions. In this subclause, <code>r</code> is an instance of a
<code>Range</code> type <code>R</code>. <code>i</code> is an instance of
<code>I</code>, known as <code>R</code>'s iterator type. <code>V</code> is
<code>R</code>'s and <code>I</code>'s value type.</p>

<p>[Note: These requirements are intended to match the requirements on
<code>_RangeT</code> in the range-based for loop ([stmt.ranged]). —endnote]</p>

<h5 id="range.requirements.implementations">Add a sub-section under [range.requirements],  "#.1 Functions taking Range types [range.requirements.implementations]"</h5>

<p>R is a <code>Range</code> type if it satisfies the requirements in Table 29
when the expressions are evaluated in the context described below.</p>

<table>
<caption>Table 29 &#x2014; <code>Range</code> requirements</caption>
<tr><th>Expression</th><th>Return type</th></tr>
<tr><td><code>begin(r)</code></td><td><code>I</code></td></tr>
<tr><td><code>end(r)</code></td><td><code>I</code></td></tr>
<tr><td><code>*i</code></td><td>implicitly convertible to <code>V</code></td></tr>
</table>

<p>The context in which <code>begin(r)</code> and <code>end(r)</code> are
evaluated shall ensure that a unary non-member function named "begin" or "end"
respectively is selected via overload resolution ([over.match]) on a candidate
set that includes:</p>
<ul>
<li>the three begin or end function templates defined in &lt;iterator> ([iterator.range]) and</li>
<li>the lookup set produced by argument-dependent lookup ([basic.lookup.argdep]).</li>
</ul>

<p>[Note: If R is an array of fundamental type and the declarations from the
header &lt;iterator> are in scope, the overall lookup set described above is
equivalent to that of the qualified name lookup applied to the expression
std::begin(r) or std::end(r) as appropriate. — end note ]</p>

<p>[ Note: It is unspecified whether a library component that has a
<code>Range</code> requirement includes the header &lt;iterator> to ensure an
appropriate evaluation context. — end note ]</p>

<p>Several functions in the standard library take a template argument named
"<code>Range</code>". These functions shall not participate in overload
resolution if <code>Range</code> is not deduced to a <code>Range</code>
type. Further, if the function is a container or string’s constructor or
<code>operator=</code>, and <code>decay&lt;Range>::type</code> is the type of
the container or a type derived from the container type, the function shall not
participate in overload resolution.</p>

<p>Additionally, implementations may exclude these functions from overload
resolution if <code>Range</code>'s iterator type is not an Input Iterator type
([input.iterators]) or its value type is not convertible to the container's
value type, but the extent to which they do so is unspecified.</p>

<p id="unspecified-state">If the <code>Range</code> is passed as an rvalue, it
is left in an unspecified state after the call. [Footnote: This allows
implementations to detect arguments that are containers and move, instead of
copying, their contents. -- end footnote]</p>

<h5 id="range.requirements.calls">Add a sub-section under [range.requirements],  "#.2 Passing Range arguments [range.requirements.calls]"</h5>

<p>In calls to functions taking template arguments named <code>Range</code>, if
<code>Range</code>'s iterator type does not satisfy at least the Input Iterator
requirements ([input.iterators]), the program is ill-formed, no diagnostic
required.  If a Range object <code>r</code> is passed such that
<code>[begin(r),end(r))</code> is not a valid range
([iterator.requirements.general]), the behavior is undefined.</p>


<h3 id="strings">Clause 21, Strings library</h3>

<h4>Add to the std::basic_string definition in [basic.string]</h4>
<pre><code>    template&lt;class Range>
      explicit basic_string(Range&&, const Allocator& = Allocator());
    template&lt;class Range>
      basic_string& operator=(Range&&);
    template&lt;class Range>
      basic_string& operator+=(Range&&);
    template&lt;class Range>
      basic_string& append(Range&&);
    template&lt;class Range>
      basic_string& assign(Range&&);
    template&lt;class Range>
      iterator insert(const_iterator p, Range&&);
    template&lt;class Range>
      basic_string& replace(const_iterator, const_iterator, Range&&);</code></pre>

<h4>Add overloads to [string.cons]</h4>
<pre><code>template&lt;typename Range>
  explicit basic_string(Range&& range, const Allocator& a = Allocator());</code></pre>
<div class="attributes">
  <p>Effects: Same as basic_string(begin(range), end(range), a).</p>
</div>

<pre><code>template&lt;typename Range>
  basic_string& operator=(Range&& range);</code></pre>
<div class="attributes">
  <p>Effects: *this = basic_string(std::forward&lt;Range>(range)).</p>
  <p>Returns: *this.</p>
</div>

<h4>Add an overload to [string::op+=]</h4>
<pre><code>template&lt;class Range>
  basic_string& operator+=(Range&& range);</code></pre>
<div class="attributes">
  <p>Effects: Calls append(std::forward&lt;Range>(range)).</p>
  <p>Returns: *this.</p>
</div>

<h4>Add an overload to [string::append]</h4>
<pre><code>template&lt;class Range>
  basic_string& append(Range&& range);</code></pre>
<div class="attributes">
  <p>Effects: Calls append(begin(range), end(range)).</p>
  <p>Returns: *this.</p>
</div>

<h4>Add an overload to [string::assign]</h4>
<pre><code>template&lt;class Range>
  basic_string& assign(Range&& range);</code></pre>
<div class="attributes">
  <p>Effects: Calls assign(begin(range), end(range)).</p>
  <p>Returns: *this.</p>
</div>

<h4>Add an overload to [string::insert]</h4>
<pre><code>template&lt;class Range>
  iterator insert(const_iterator p, Range&& range);</code></pre>
<div class="attributes">
  <p>Effects: insert(p, begin(range), end(range)).</p>
  <p>Returns: An iterator which refers to the copy of the first inserted
  character, or p if <code>[begin(range),end(range))</code> is an empty
  range.</p>
</div>

<h4>Add an overload to [string::replace]</h4>
<pre><code>template&lt;class Range>
  basic_string& replace(const_iterator i1, const_iterator i2,
                        Range&& range);</code></pre>
<div class="attributes">
  <p>Requires: [begin(),i1), [i1,i2), and [begin(range),end(range)) are valid ranges.</p>
  <p>Effects: Calls replace(i1 - begin(), i2 - i1, begin(range), end(range)).</p>
  <p>Returns: *this.</p>
</div>


<h3 id="containers">Clause 23, Containers library</h3>

<h4>Modify [sequence.reqmts]</h4>
<p>In Tables 101 and 102, X denotes a sequence container class, a denotes a
value of X containing elements of type T, A denotes X::allocator_type if it
exists and std::allocator&lt;T> if it doesn’t, i and j denote iterators
satisfying input iterator requirements and refer to elements implicitly
convertible to value_type, [i, j) denotes a valid range, <ins>r denotes a
<code>Range</code> object ([range.requirements.implementations]) whose value
type is implicitly convertible to value_type and for which [begin(r),end(r)) is
a valid range ([iterator.requirements.general]), </ins>il designates an object
of type
initializer_list&lt;value_type>, n denotes a value of X::size_type, p denotes a
valid const iterator to a, q denotes a valid dereferenceable const iterator to
a, [q1, q2) denotes a valid range of const iterators in a, t denotes an lvalue
or a const rvalue of X::value_- type, and rv denotes a non-const rvalue of
X::value_type. Args denotes a template parameter pack; args denotes a function
parameter pack with the pattern Args&&.</p>

<h4>Add rows to Table 101 — Sequence container requirements (in addition to container)</h4>

<table>
  <tr><th>Expression</th><th>Return type</th><th>Assertion/note<br/>pre-/post-condition</th></tr>
  <tr><td>X(r);</td><td></td><td>Equivalent to X(begin(r), end(r))</td></tr>
<tr><td>a = r;</td>
<td>X&</td><td>Requires: T is CopyInsertable into X and CopyAssignable. Assigns the range
[begin(r),end(r)) into a. All existing elements of a are either assigned to or destroyed.
Returns: *this.</td></tr>
<tr><td>a.insert(p, r);</td><td>iterator</td><td>a.insert(p, begin(r), end(r)).</td></tr>
<tr><td>a.assign(r)</td><td>void</td><td>a.assign(begin(r), end(r)).</td></tr>
</table>

<h4>Modify [associative.reqmts]</h4>
<p>In Table 103, X denotes an associative container class, a denotes a value of
X, a_uniq denotes a value of X when X supports unique keys, a_eq denotes a value
of X when X supports multiple keys, u denotes an identifier, i and j satisfy
input iterator requirements and refer to elements implicitly convertible to
value_type, [i,j) denotes a valid range, p denotes a valid const iterator to a,
q denotes a valid dereferenceable const iterator to a, [q1, q2) denotes a valid
range of const iterators in a, <ins>r denotes a <code>Range</code> object
([range.requirements.implementations]) whose value type is implicitly
convertible to value_type and for which [begin(r),end(r)) is a valid range
([iterator.requirements.general]), </ins>il designates an object of type
initializer_list&lt;value_type>, t denotes a value of X::value_type, k denotes a
value of X::key_type and c denotes a value of type X::key_compare. A denotes the
storage allocator used by X, if any, or std::allocator&lt;X::value_type>
otherwise, and m denotes an allocator of a type convertible to A.</p>

<h4>Add rows to Table 103 — Associative container requirements (in addition to container)</h4>
<table>
  <tr><th>Expression</th><th>Return type</th><th>Assertion/note<br/>pre-/post-condition</th><th>Complexity</th></tr>
<tr><td>X(r);</td><td></td><td>Same as X(begin(r), end(r)).</td><td>same as X(begin(r), end(r)).</td></tr>
<tr><td>a = r</td><td>X&</td>
<td>Requires: value_type is CopyInsertable into X and CopyAssignable.
Effects: Assigns the range [begin(r),end(r)) into a. All existing elements of a are either assigned to or destroyed.</td>
<td>NlogN in general (where N has the value distance(begin(r), end(r)) + a.size()); linear if [begin(r),end(r)) is sorted with value_comp().</td></tr>
<tr><td>a.insert(r)</td><td>void</td><td>Equivalent to a.insert(begin(r),
end(r)).</td><td></td></tr>
</table>

<h4>Modify [unord.req]</h4>

<p>In table 104: X is an unordered associative container class, a is an object
of type X, b is a possibly const object of type X, a_uniq is an object of type X
when X supports unique keys, a_eq is an object of type X when X supports
equivalent keys, i and j are input iterators that refer to value_type, [i, j) is
a valid range, p and q2 are valid const iterators to a, q and q1 are valid
dereferenceable const iterators to a, [q1, q2) is a valid range in a, <ins>r
denotes a <code>Range</code> object ([range.requirements.implementations]) whose
value type is implicitly convertible to value_type and for which
[begin(r),end(r)) is a valid range ([iterator.requirements.general]), </ins>il
designates an object of type
initializer_list&lt;value_type>, t is a value of type X::value_type, k is a
value of type key_type, hf is a possibly const value of type hasher, eq is a
possibly const value of type key_equal, n is a value of type size_type, and z is
a value of type float.</p>

<h4>Add rows to Table 104 — Unordered associative container requirements (in addition to container)</h4>
<table>
  <tr><th>Expression</th><th>Return type</th><th>Assertion/note<br/>pre-/post-condition</th><th>Complexity</th></tr>
<tr><td>X(r)</td><td>X</td><td>Same as X(begin(r), end(r)).</td><td>Same as X(begin(r), end(r)).</td></tr>
<tr><td>a = r</td><td>X&</td>
<td>Requires: value_type is CopyInsertable into X and CopyAssignable.
Effects: Assigns the range [begin(r),end(r)) into a. All existing elements of a are either assigned to or destroyed.</td>
<td>Same as a = X(r).</td></tr>
<tr><td>a.insert(r)</td><td>void</td><td>Same as a.insert(begin(r), end(r)).</td><td>Same as a.insert( begin(r),
end(r)).</td></tr>
</table>

<h4>Add to the std::deque definition in [deque.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit deque(Range&&, const Allocator& = Allocator());
    template &lt;class Range>
      deque& operator=(Range&&);
    template &lt;class Range>
      void assign(Range&&);
    template &lt;class Range>
      iterator insert(const_iterator position, Range&&);
</code></pre>

<h4>Add an insert overload to [deque.modifiers]</h4>
<pre><code>template &lt;class Range>
  iterator insert(const_iterator position, Range&&);</code></pre>


<h4>Add to the std::forward_list definition in [forwardlist.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit forward_list(Range&&, const Allocator& = Allocator());
    template &lt;class Range>
      forward_list& operator=(Range&&);
    template &lt;class Range>
      void assign(Range&&);
    template &lt;class Range>
      iterator insert_after(const_iterator position, Range&& range);</code></pre>

<h4>Add an insert_after overload to [forwardlist.modifiers]</h4>

<pre><code>template &lt;class Range>
  iterator insert_after(const_iterator position, Range&& range);</code></pre>
<div class="attributes">
  <p>Effects: insert_after(p, begin(range), end(range)).</p>
  <p>Returns: An iterator pointing to the last inserted element or
  <code>position</code> if <code>[begin(range),end(range))</code> is an empty
  range.</p>
</div>


<h4>Add to the std::list definition in [list.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit list(Range&&, const Allocator& = Allocator());
    template &lt;class Range>
      list& operator=(Range&&);
    template &lt;class Range>
      void assign(Range&&);
    template &lt;class Range>
      iterator insert(const_iterator position, Range&& range);</code></pre>

<h4>Add an insert overload to [list.modifiers]</h4>
<pre><code>template &lt;class Range>
  iterator insert(const_iterator position, Range&&);</code></pre>

<h4>Add to the std::vector definition in [vector.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit vector(Range&&, const Allocator& = Allocator());
    template &lt;class Range>
      vector& operator=(Range&&);
    template &lt;class Range>
      void assign(Range&&);
    template &lt;class Range>
      iterator   insert(const_iterator position, Range&& range);</code></pre>

<h4>Add an insert overload to [vector.modifiers]</h4>
<pre><code>template &lt;class Range>
  iterator insert(const_iterator position, Range&&);</code></pre>

<h4>Add to the std::vector&lt;bool> definition in [vector.bool]</h4>
<pre><code>    template &lt;class Range>
      vector(Range&&, const Allocator& = Allocator()));
    template &lt;class Range>
      vector operator=(Range&&);
    template &lt;class Range>
      void assign(Range&&);
    template &lt;class Range>
        iterator insert(const_iterator position, Range&& range);</code></pre>

<h4>Add to the std::map definition in [map.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit map(Range&&,
        const Compare& = Compare(),
        const Allocator& = Allocator());
    template &lt;class Range>
      map& operator=(Range&&);
    template &lt;class Range>
      void insert(Range&&);</code></pre>

<h4>Add to the std::multimap definition in [multimap.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit multimap(Range&&,
        const Compare& = Compare(),
        const Allocator& = Allocator());
    template &lt;class Range>
      multimap& operator=(Range&&);
    template &lt;class Range> void insert(Range&&);</code></pre>


<h4>Add to the std::set definition in [set.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit set(Range&&,
        const Compare& = Compare(),
        const Allocator& = Allocator());
    template &lt;class Range>
      set& operator=(Range&&);
    template &lt;class Range>
      void insert(Range&&);</code></pre>

<h4>Add to the std::multiset definition in [multiset.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit multiset(Range&&,
        const Compare& = Compare(),
        const Allocator& = Allocator());
    template &lt;class Range>
      multiset& operator=(Range&&);
    template &lt;class Range>
      void insert(Range&&);</code></pre>

<h4>Add to the std::unordered_map definition in [unord.map.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit unordered_map(Range&&,
        size_type = see below,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
    template &lt;class Range>
      unordered_map& operator=(Range&&);
    template &lt;class Range> void insert(Range&&);</code></pre>

<h4>Add to the std::unordered_multimap definition in [unord.multimap.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit unordered_multimap(Range&&,
        size_type = see below,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
    template &lt;class Range>
      unordered_multimap& operator=(Range&&);
    template &lt;class Range> void insert(Range&&);</code></pre>

<h4>Add to the std::unordered_set definition in [unord.set.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit unordered_set(Range&&,
        size_type = see below,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
    template &lt;class Range>
      unordered_set& operator=(Range&&);
    template &lt;class Range> void insert(Range&&);</code></pre>

<h4>Add to the std::unordered_multiset definition in [unord.multiset.overview]</h4>
<pre><code>    template &lt;class Range>
      explicit unordered_multiset(Range&&,
        size_type = see below,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
    template &lt;class Range>
      unordered_multiset& operator=(Range&&);
    template &lt;class Range> void insert(Range&&);</code></pre>
  </section>

  <section>
    <h2 id="acknowledgements">Acknowledgements</h2>

    <p>I'd like to thank Daniel Krügler for help with the wording in this
    paper, although any remaining mistakes are mine.</p>
  </section>

</body>
</html>
